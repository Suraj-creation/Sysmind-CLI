"""
SYSMIND Process Watchdog Module

Automated process monitoring with rules and actions.
"""

import os
import time
import threading
import fnmatch
from datetime import datetime
from typing import List, Dict, Optional, Any, Callable
from dataclasses import dataclass, field

from .manager import ProcessManager, ProcessInfo
from ...core.database import Database
from ...core.errors import ProcessError


@dataclass
class WatchdogRule:
    """Rule for process monitoring."""
    id: str
    name: str
    pattern: str  # Process name pattern (supports wildcards)
    
    # Conditions
    cpu_threshold: Optional[float] = None  # CPU % threshold
    memory_threshold: Optional[int] = None  # Memory bytes threshold
    min_count: Optional[int] = None  # Minimum instance count
    max_count: Optional[int] = None  # Maximum instance count
    
    # Actions
    action: str = 'alert'  # alert, log, kill, notify
    
    # Status
    enabled: bool = True
    last_triggered: Optional[datetime] = None
    trigger_count: int = 0


@dataclass
class WatchdogAlert:
    """Alert generated by watchdog."""
    rule_id: str
    rule_name: str
    process: Optional[ProcessInfo]
    condition: str
    message: str
    severity: str  # info, warning, critical
    timestamp: datetime = field(default_factory=datetime.now)


class ProcessWatchdog:
    """
    Process watchdog for automated monitoring.
    
    Monitors processes against defined rules and takes
    configured actions when thresholds are exceeded.
    """
    
    def __init__(
        self,
        database: Optional[Database] = None,
        check_interval: float = 30.0
    ):
        """
        Initialize watchdog.
        
        Args:
            database: Optional database for rule persistence
            check_interval: Seconds between checks
        """
        self.database = database
        self.check_interval = check_interval
        
        self.manager = ProcessManager()
        self.rules: Dict[str, WatchdogRule] = {}
        
        self._running = False
        self._thread: Optional[threading.Thread] = None
        self._alert_callbacks: List[Callable[[WatchdogAlert], None]] = []
        self._alerts: List[WatchdogAlert] = []
        self._max_alerts = 1000
        
        # Load rules from database
        self._load_rules()
    
    def _load_rules(self):
        """Load rules from database."""
        if not self.database:
            return
        
        rules = self.database.get_watchdog_rules()
        for rule_data in rules:
            rule = WatchdogRule(
                id=rule_data['id'],
                name=rule_data['name'],
                pattern=rule_data['pattern'],
                cpu_threshold=rule_data.get('cpu_threshold'),
                memory_threshold=rule_data.get('memory_threshold'),
                min_count=rule_data.get('min_count'),
                max_count=rule_data.get('max_count'),
                action=rule_data.get('action', 'alert'),
                enabled=rule_data.get('enabled', True)
            )
            self.rules[rule.id] = rule
    
    def _save_rule(self, rule: WatchdogRule):
        """Save rule to database."""
        if self.database:
            self.database.save_watchdog_rule(
                rule_id=rule.id,
                name=rule.name,
                pattern=rule.pattern,
                cpu_threshold=rule.cpu_threshold,
                memory_threshold=rule.memory_threshold,
                min_count=rule.min_count,
                max_count=rule.max_count,
                action=rule.action,
                enabled=rule.enabled
            )
    
    def add_rule(self, rule: WatchdogRule):
        """
        Add a watchdog rule.
        
        Args:
            rule: Rule to add
        """
        self.rules[rule.id] = rule
        self._save_rule(rule)
    
    def remove_rule(self, rule_id: str) -> bool:
        """
        Remove a watchdog rule.
        
        Args:
            rule_id: ID of rule to remove
        
        Returns:
            True if rule was removed
        """
        if rule_id in self.rules:
            del self.rules[rule_id]
            if self.database:
                self.database.delete_watchdog_rule(rule_id)
            return True
        return False
    
    def enable_rule(self, rule_id: str):
        """Enable a rule."""
        if rule_id in self.rules:
            self.rules[rule_id].enabled = True
            self._save_rule(self.rules[rule_id])
    
    def disable_rule(self, rule_id: str):
        """Disable a rule."""
        if rule_id in self.rules:
            self.rules[rule_id].enabled = False
            self._save_rule(self.rules[rule_id])
    
    def list_rules(self) -> List[WatchdogRule]:
        """List all rules."""
        return list(self.rules.values())
    
    def on_alert(self, callback: Callable[[WatchdogAlert], None]):
        """Register an alert callback."""
        self._alert_callbacks.append(callback)
    
    def _emit_alert(self, alert: WatchdogAlert):
        """Emit an alert to callbacks."""
        self._alerts.append(alert)
        if len(self._alerts) > self._max_alerts:
            self._alerts = self._alerts[-self._max_alerts:]
        
        for callback in self._alert_callbacks:
            try:
                callback(alert)
            except:
                pass
        
        # Save to database
        if self.database:
            self.database.save_alert(
                alert_type='watchdog',
                severity=alert.severity,
                message=alert.message,
                source=alert.rule_name,
                details={
                    'rule_id': alert.rule_id,
                    'condition': alert.condition,
                    'process_pid': alert.process.pid if alert.process else None,
                    'process_name': alert.process.name if alert.process else None,
                }
            )
    
    def _match_pattern(self, name: str, pattern: str) -> bool:
        """Check if process name matches pattern."""
        return fnmatch.fnmatch(name.lower(), pattern.lower())
    
    def _check_rule(self, rule: WatchdogRule, processes: List[ProcessInfo]) -> List[WatchdogAlert]:
        """Check a single rule against processes."""
        alerts = []
        
        # Find matching processes
        matching = [p for p in processes if self._match_pattern(p.name, rule.pattern)]
        
        # Check count constraints
        if rule.min_count is not None and len(matching) < rule.min_count:
            alerts.append(WatchdogAlert(
                rule_id=rule.id,
                rule_name=rule.name,
                process=None,
                condition='min_count',
                message=f"Process '{rule.pattern}' count ({len(matching)}) below minimum ({rule.min_count})",
                severity='warning'
            ))
        
        if rule.max_count is not None and len(matching) > rule.max_count:
            alerts.append(WatchdogAlert(
                rule_id=rule.id,
                rule_name=rule.name,
                process=matching[0] if matching else None,
                condition='max_count',
                message=f"Process '{rule.pattern}' count ({len(matching)}) exceeds maximum ({rule.max_count})",
                severity='warning'
            ))
        
        # Check resource thresholds for each matching process
        for proc in matching:
            # CPU threshold
            if rule.cpu_threshold and proc.cpu_percent > rule.cpu_threshold:
                alerts.append(WatchdogAlert(
                    rule_id=rule.id,
                    rule_name=rule.name,
                    process=proc,
                    condition='cpu_threshold',
                    message=f"Process '{proc.name}' (PID {proc.pid}) CPU ({proc.cpu_percent:.1f}%) exceeds threshold ({rule.cpu_threshold}%)",
                    severity='critical' if proc.cpu_percent > rule.cpu_threshold * 1.5 else 'warning'
                ))
            
            # Memory threshold
            if rule.memory_threshold and proc.memory_rss > rule.memory_threshold:
                mem_mb = proc.memory_rss / (1024 * 1024)
                thresh_mb = rule.memory_threshold / (1024 * 1024)
                alerts.append(WatchdogAlert(
                    rule_id=rule.id,
                    rule_name=rule.name,
                    process=proc,
                    condition='memory_threshold',
                    message=f"Process '{proc.name}' (PID {proc.pid}) memory ({mem_mb:.1f} MB) exceeds threshold ({thresh_mb:.1f} MB)",
                    severity='critical' if proc.memory_rss > rule.memory_threshold * 1.5 else 'warning'
                ))
        
        return alerts
    
    def _take_action(self, alert: WatchdogAlert, rule: WatchdogRule):
        """Take action for an alert based on rule configuration."""
        if rule.action == 'kill' and alert.process:
            try:
                self.manager.kill_process(alert.process.pid, force=False)
            except:
                pass
        
        # Update rule stats
        rule.last_triggered = datetime.now()
        rule.trigger_count += 1
        self._save_rule(rule)
    
    def check_now(self) -> List[WatchdogAlert]:
        """
        Run a single check cycle.
        
        Returns:
            List of alerts generated
        """
        processes = self.manager.list_processes()
        all_alerts = []
        
        for rule in self.rules.values():
            if not rule.enabled:
                continue
            
            alerts = self._check_rule(rule, processes)
            
            for alert in alerts:
                self._emit_alert(alert)
                self._take_action(alert, rule)
            
            all_alerts.extend(alerts)
        
        return all_alerts
    
    def _watchdog_loop(self):
        """Main watchdog loop."""
        while self._running:
            try:
                self.check_now()
            except Exception:
                pass
            
            time.sleep(self.check_interval)
    
    def start(self):
        """Start the watchdog background thread."""
        if self._running:
            return
        
        self._running = True
        self._thread = threading.Thread(target=self._watchdog_loop, daemon=True)
        self._thread.start()
    
    def stop(self):
        """Stop the watchdog."""
        self._running = False
        if self._thread:
            self._thread.join(timeout=self.check_interval + 1)
            self._thread = None
    
    def get_alerts(
        self,
        limit: int = 100,
        rule_id: Optional[str] = None,
        severity: Optional[str] = None
    ) -> List[WatchdogAlert]:
        """
        Get recent alerts.
        
        Args:
            limit: Maximum number of alerts to return
            rule_id: Filter by rule ID
            severity: Filter by severity
        
        Returns:
            List of alerts (newest first)
        """
        alerts = self._alerts.copy()
        alerts.reverse()
        
        if rule_id:
            alerts = [a for a in alerts if a.rule_id == rule_id]
        
        if severity:
            alerts = [a for a in alerts if a.severity == severity]
        
        return alerts[:limit]
    
    def create_preset_rules(self) -> List[WatchdogRule]:
        """
        Create preset monitoring rules.
        
        Returns:
            List of created rules
        """
        presets = [
            WatchdogRule(
                id='high_cpu_any',
                name='High CPU Usage',
                pattern='*',
                cpu_threshold=90.0,
                action='alert'
            ),
            WatchdogRule(
                id='high_memory_any',
                name='High Memory Usage',
                pattern='*',
                memory_threshold=1024 * 1024 * 1024,  # 1 GB
                action='alert'
            ),
            WatchdogRule(
                id='chrome_memory',
                name='Chrome Memory Hog',
                pattern='chrome*',
                memory_threshold=2 * 1024 * 1024 * 1024,  # 2 GB
                action='alert'
            ),
        ]
        
        for rule in presets:
            if rule.id not in self.rules:
                self.add_rule(rule)
        
        return presets
